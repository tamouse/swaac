As part of my volunteering with [[https://gdiminneapolis.com][GDI
Minneapolis]], I've been getting back into WordPress development (child
themes, custom themes, etc.), while TAing, teaching, and helping develop
some classes. One of the key things we want to show students is how to
develop their sites safely and learn the trade of software development
in the WordPress environment.

There are several ways one can do this. There are some really
/excellent/ tools out there now that make this a snap for people not
versed in setting things up themselves.

- [[https://local.getflywheel.com][Local by Flywheel]]
- [[https://serverpress.com/get-desktopserver/][DesktopServer from
  ServerPress]]

There are also traditional ways of installing
[[https://www.mamp.info/en/][MAMP]] on MacOSx, or using a
[[https://www.turnkeylinux.org/wordpress][Turnkey Linux WordPress
Appliance]], and so many other ways.

This is how I set up my local environment using two tools I use heavily
in other areas of web development:

- [[https://www.vagrantup.com/][Vagrant]]
- [[https://www.ansible.com/][Ansible]]

--------------

First off, this is going to be less of a tutorial and more a description
of what I'm doing. I'm definitely not holding this out as a definitive
way to set up your local WordPress development environment, but /my/ way
that works for me. If you're brand new to all this, and don't want to
learn all about systems and devops, then I recommend using one of the
first two options above. (I've played a bit with
[[https://local.getflywheel.com][Local]], and find it amazingly
intuitive and simple, so that's my latest recommendation.)

Secondly, the sandbox setup is available on GitHub at
[[https://github.com/tamouse/sandbox.wp.local][github.com/tamouse/sandbox.wp.local]]
so feel free to fork it, and do what you want with it. I'll happily take
PRs if you find bugs, too.

--------------

** Starting Point
   :PROPERTIES:
   :CUSTOM_ID: starting-point
   :END:

My working system:

- Macbook Pro 13"
- 8 GiB RAM
- 4 CPU Cores
- about 50 GiB free disk space (I didn't need anywhere near this, it's
  just what was there when I started.)

** Prerequisites
   :PROPERTIES:
   :CUSTOM_ID: prerequisites
   :END:

*** Available Software
    :PROPERTIES:
    :CUSTOM_ID: available-software
    :END:

This is stuff I already had on my system because of other development I
do.

- HomeBrew
- VirtualBox
- Vagrant
- Ansible

** Steps to Get Things Set Up
   :PROPERTIES:
   :CUSTOM_ID: steps-to-get-things-set-up
   :END:

*** Create a project folder and initialize it
    :PROPERTIES:
    :CUSTOM_ID: create-a-project-folder-and-initialize-it
    :END:

I always start my projects the same way:

#+BEGIN_EXAMPLE
    mkdir -p ~/Projects/wordpress-stuff/sandbox.wp.local
    cd ~/Projects/wordpress-stuff/sandbox.wp.local
    git init
    echo 'Local WordPress Development Sandbox running in Vagrant with Ansible Provisioning' | tee README.md > .git/description
    hub create -d "$(cat .git/description)"
    git add -Av
    git commit -m 'initial commit'
    git push -u origin master
#+END_EXAMPLE

(Truth be told, this is one of my bash functions, so it really looked
like this:

#+BEGIN_EXAMPLE
    new_proj sandbox.wp.local 'Local WordPress Development Sandbox running in Vagrant with Ansible Provisioning' 'initial commit'
#+END_EXAMPLE

)

*** Run =vagrant init=
    :PROPERTIES:
    :CUSTOM_ID: run-vagrant-init
    :END:

I typically use one of the later Ubuntu server variants; mostly I've
been using 'trusty':

#+BEGIN_SRC sh
    vagrant init 'ubuntu/trusty64'
#+END_SRC

This writes out a default =Vagrantfile= (which is written in Ruby).

*** Modify =Vagrantfile= for my needs
    :PROPERTIES:
    :CUSTOM_ID: modify-vagrantfile-for-my-needs
    :END:

I modify the file so it looks like so:

{% highlight ruby linenos %} BOX\_NAME="sandbox.wp.local"
DEFAULT\_IP="192.168.33.35"

require "resolv"

def my\_ip @my\_ip ||= Resolv::Hosts.new.getaddress(BOX\_NAME) ||
DEFAULT\_IP rescue @my\_ip ||= DEFAULT\_IP end Vagrant.configure(2) do
|config|

config.ssh.forward\_agent = true

config.vm.define :sandbox\_wp do |sb| sb.vm.box = "ubuntu/trusty64"
sb.vm.network "private\_network", ip: my\_ip sb.vm.network
"forwarded\_port", guest: 80, host: 8088 sb.vm.hostname = BOX\_NAME

#+BEGIN_EXAMPLE
    sb.vm.provider "virtualbox" do |vb|
      # Display the VirtualBox GUI when booting the machine
      # vb.gui = true

      # Customize the amount of memory on the VM:
      vb.customize ["modifyvm", :id, "--memory", "2048"]
      vb.customize ["modifyvm", :id, "--vram", "18"]
      vb.customize ["modifyvm", :id, "--cpus", "2"]
      vb.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
    end
#+END_EXAMPLE

end

config.vm.provision :ansible do |a| a.playbook = 'ansible/sandbox.yml' #
a.verbose = 'vvvv' end end {% endhighlight %}

Some explanation about the various settings:

#+BEGIN_SRC ruby
    BOX_NAME="sandbox.wp.local"
    DEFAULT_IP="192.168.33.35"
#+END_SRC

These define two constants that get used later in the =Vagrantfile=. I
edited my machine's =/etc/hosts= file, which maps IP addresses to
hostnames locally. The line I added to =/etc/hosts= looks like so:

#+BEGIN_EXAMPLE
    192.168.33.35   sandbox.wp.local sandbox
#+END_EXAMPLE

This lets me type 'http://sandbox/' or 'http://sandbox.wp.local' in the
browser address bar to access the web server that will be running in the
Vagrant Virtual Machine (aka "VM").

(Note: when I used [[https://local.getflywheel.com][Local]], it did
something similar.)

Then I'm bringing in ruby's =resolv= standard library, which gives the
ability to use that mapping given in the =/etc/hosts= file; the
=DEFAULT_IP= constant provides a fallback in case it can't find
=BOX_NAME= in =/etc/hosts=.

The =my_ip= method defined sets and returns the IP address to be used
for my WordPress sandbox.

With all that handled, vagrant can begin it's configuration. Most
everything from here out can be found in vagrant's documentation, if you
want.

#+BEGIN_SRC ruby
      config.ssh.forward_agent = true
#+END_SRC

I set this to true so when I'm logged into the vagrant box, it will use
my ssh keys from my development machine; this is especially helpful when
using git commands that talk to GitHub, etc.

#+BEGIN_SRC ruby
        sb.vm.network  "private_network", ip: my_ip
#+END_SRC

Here is where that calculation for figuring out what IP address to use
that matches the name 'sandbox.wp.local' I set up is made.

#+BEGIN_SRC ruby
        sb.vm.hostname = BOX_NAME
#+END_SRC

This sets the VM host name, so it will match 'sandbox.wp.local' when I'm
logged in.

#+BEGIN_SRC ruby
          vb.customize ["modifyvm", :id, "--memory", "2048"]
#+END_SRC

This reserves 2GiB of RAM for the VM.

#+BEGIN_SRC ruby
          vb.customize ["modifyvm", :id, "--vram", "18"]
#+END_SRC

This reserves 18MB of RAM for the video buffer.

#+BEGIN_SRC ruby
          vb.customize ["modifyvm", :id, "--cpus", "2"]
#+END_SRC

This allows up to 2 CPU Cores to be used by the VM.

#+BEGIN_SRC ruby
          vb.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
#+END_SRC

This does some magic to use the host machine's DNS resolver to find IP
address, which pulls in the magic of mapping 'sandbox.wp.local'.

#+BEGIN_SRC ruby
      config.vm.provision :ansible do |a|
#+END_SRC

Tells vagrant I'm using Ansible provisioning.

#+BEGIN_SRC ruby
        a.playbook = 'ansible/sandbox.yml'
#+END_SRC

Specifies the Ansible 'playbook'

#+BEGIN_SRC ruby
        # a.verbose  = 'vvvv'
#+END_SRC

Leaving this commented out, but usually it's uncommented for me to be
able to debug things during provisioning.

*** Make a git savepoint
    :PROPERTIES:
    :CUSTOM_ID: make-a-git-savepoint
    :END:

Committing the current changes at this point to create a "save point" to
get back to if I end up mucking things up.

#+BEGIN_EXAMPLE
    git add -Av && git commit -m 'Vagrantfile updated' && git push
#+END_EXAMPLE

(And this is also a bash function:

#+BEGIN_SRC sh
    gacp 'Vagrantfile updated'
#+END_SRC

)

At this point, I decided I would make a branch to work on Ansible stuff,
too:

#+BEGIN_SRC sh
    git checkout -b ansible-playbook
#+END_SRC

*** Create the Anisble Playbook
    :PROPERTIES:
    :CUSTOM_ID: create-the-anisble-playbook
    :END:

Ansible playbooks are build as YAML files, which is just a way of
specifying structured data. It's akin to JSON and XML.

I made the ansible playbook in the =ansible= subdirectory, the structure
is:

#+BEGIN_EXAMPLE
    ansible/
      group_vars/
        all.yml
      roles/
        external/
          .keep
        internal/
          cleanup/
            tasks/
              main.yml
          common/
            tasks/
              install.yml
              main.yml
        requirements.yml
      sandbox.yml
      sudo_roles.yml
#+END_EXAMPLE

*** Top level playbook
    :PROPERTIES:
    :CUSTOM_ID: top-level-playbook
    :END:

[[https://github.com/tamouse/sandbox.wp.local/blob/master/ansible/sandbox.yml][=sandbox.yml=]]
is the top-level playbook that sets the whole provisioning activity off.
It is simple and just contains:

#+BEGIN_EXAMPLE
    ---
    - include: sudo_roles.yml
#+END_EXAMPLE

*** Sudo Roles Playbook
    :PROPERTIES:
    :CUSTOM_ID: sudo-roles-playbook
    :END:

[[https://github.com/tamouse/sandbox.wp.local/blob/master/ansible/sudo_roles.yml][=sudo_roles.yml=]]
is the playbook that runs all the roles that need to be performs as the
superuser. In this project, that's all of them. My playbook goes in the
following order:

- internal/common
- external/calebwoods.brightbox\_ruby
- external/geerlingguy.nodejs
- external/geerlingguy.apache
- external/geerlingguy.mysql
- external/geerlingguy.php
- external/darthwade.wordpress
- external/darthwade.wordpress-apache
- internal/cleanup

*** Defining External Requirements
    :PROPERTIES:
    :CUSTOM_ID: defining-external-requirements
    :END:

In building this up, my starting point was to figure out what pre-built
roles I could use to install the software and configurations I would
need. These filled out
[[https://github.com/tamouse/sandbox.wp.local/blob/master/ansible/roles/requirements.yml][=roles/requirements.yml=]].
I'm using these roles:

- [[https://galaxy.ansible.com/geerlingguy/nodejs/][=geerlingguy.nodejs=]] -
  installs the latest stable version of Node.js
- [[https://galaxy.ansible.com/geerlingguy/apache/][=geerlingguy.apache=]] -
  the Apache 2.x web server
- [[https://galaxy.ansible.com/geerlingguy/mysql/][=geerlingguy.mysql=]] -
  MySQL database management system, 5.x
- [[https://galaxy.ansible.com/geerlingguy/php/][=geerlingguy.php=]] -
  PHP language, 5.x
- [[https://galaxy.ansible.com/darthwade/wordpress/][=darthwade.wordpress=]] -
  WordPress installation
- [[https://galaxy.ansible.com/darthwade/wordpress-apache/][=darthwade.wordpress-apache=]] -
  Apache requirements for WordPress
- [[https://galaxy.ansible.com/calebwoods/brightbox_ruby/][=calebwoods.brightbox_ruby=]] -
  Ruby 2.x because I like working in Ruby, too

Each of these requires some configuration. The configuration settings
are defined in
[[https://github.com/tamouse/sandbox.wp.local/blob/master/ansible/group_vars/all.yml][=group_vars/all.yml=]].
I set things up as follows:

- enable apache =rewrite_mod=
- MySQL root password
- MySQL WordPress database and user =vagrant=
- Ruby version 2.2 and 2.3
- Node.js version 6, npm user =vagrant=
- Various PHP options and modules:

  - =php5=, =php5-cli=, =php5-common=, =php5-curl=, =php5-dev=,
    =php5-gd=, =php5-mysql=
  - memory limit: 128MiB
  - execution time: 90s
  - max file upload size: 256MiB
  - disable apcu

- WordPress Configurations

  - version 4.0
  - install directory =/var/www/sandbox_wp=
  - db user: =vagrant= (match above)
  - db host: =localhost=

  - hostname: =sandbox.wp.local=
  - alias: 'sandbox'
  - admin email: "admin@example.com" (because I'm not sending any
    emails)

*** Internal Requirements
    :PROPERTIES:
    :CUSTOM_ID: internal-requirements
    :END:

These are things I installed and configured myself without relying on
pre-defined roles.

Because the =sudo_roles.yml= file calls =internal/common=,
=roles/internal/common/tasks/main.yml= gets run automatically during
provisioning. It calls in
[[https://github.com/tamouse/sandbox.wp.local/blob/master/ansible/roles/internal/common/tasks/install.yml][=roles/internal/common/tasks/install.yml=]]
which I'm using to install necessary software packages.

After updating the APT caches, I installed:

- build-essential
- ntp
- git
- vim
- emacs24
- unzip
- imagemagick
- libmagick-dev
- libxml2
- libxml2-dev

WordPress definitely doesn't need all of these, but my development tools
and workflow generally do, and that's what this is all about.

*** Final configuration and cleanup
    :PROPERTIES:
    :CUSTOM_ID: final-configuration-and-cleanup
    :END:

After installing all the internal and external roles, I still had some
things I wanted to configure and clean up. These went into
[[https://github.com/tamouse/sandbox.wp.local/blob/master/ansible/roles/internal/cleanup/tasks/main.yml][=roles/internal/cleanup/tasks/main.yml=]]
and included:

- enabling the VHosts module for Apache2
- disable the default and vhosts sites
- reset user and group ownership of the WordPress site to =www-data=
- use the =direct= method for =FS_METHOD= which lets the WordPress
  installation directly update from the codex without using FTP.

*** Another Git Save Point
    :PROPERTIES:
    :CUSTOM_ID: another-git-save-point
    :END:

Yep. This is how I roll.

#+BEGIN_SRC sh
    gacp 'Ansible Playbook Created'
#+END_SRC

*** Gathering the External Requirements
    :PROPERTIES:
    :CUSTOM_ID: gathering-the-external-requirements
    :END:

Specifying the external requirements is not enough, I needed to tell
ansible to fetch them.

#+BEGIN_SRC sh
    ansible-galaxy install -r ansible/roles/requirements.yml --force --ignore-errors
#+END_SRC

*** Bringing up the VM and first provisioning
    :PROPERTIES:
    :CUSTOM_ID: bringing-up-the-vm-and-first-provisioning
    :END:

Now I was ready to pull together all the prior stuff and build the box.

#+BEGIN_SRC sh
    vagrant up
#+END_SRC

The first time you run =up= vagrant will start running the provisioning
after the box comes up. After this first time, however, when you run the
=up= command, vagrant doesn't try to reprovision.

So, you know, the first time you try something, you mistype something,
or you forget a configuration value, and so on. I know I did. I don't
recall the specifics, but it doesn't really matter, trial and error, get
things working, figure stuff out, and eventually I ended up with a clean
provisioning.

You don't need to keep running the =up= command, you run the =provision=
command instead while the box stays up. Since the point of ansible is to
provide an "idempotent" (i.e. same result each time it's run) solution,
it will check if it's successfully run a step and skip over it. So my
provisioning actually looked something like:

#+BEGIN_SRC sh
    vagrant up
    # something broke, fix it
    vagrant provision
    # something broke, fix it
    vagrant provision
    # something broke, fix it
    vagrant provision
    # something broke, fix it
    vagrant provision
    # and so on
    vagrant provision
    # yay it finally worked!
#+END_SRC

*** And another save point, and merge back to master
    :PROPERTIES:
    :CUSTOM_ID: and-another-save-point-and-merge-back-to-master
    :END:

#+BEGIN_EXAMPLE
    gacp 'Anisble provisioning works! Yay!`
    git checkout master # aliased to: gco master
    git merge ansible-playbook
    gacp 'Merging ansible-playbook to master'
#+END_EXAMPLE

Whew!

*** Set up WordPress Installation
    :PROPERTIES:
    :CUSTOM_ID: set-up-wordpress-installation
    :END:

I was now ready to give the WordPress five-minute installation a go. I
fired up my browser at =http://sandbox.wp.local= and there was the
installation page, just as I'd hoped.

After running through that, playing with appearance, plugins, making a
couple posts and pages, I was feeling good.

I tried installing some themes and plugins from the WordPress codex, and
they installed nicely. Updated the WordPress installation itself, and
everything was great.

** Creating a development environment
   :PROPERTIES:
   :CUSTOM_ID: creating-a-development-environment
   :END:

This is really the whole point of this exercise: I wanted a sandbox that
would let me develop child and custom themes, plugins, other custom
things as I wanted, using my local machine to edit things, and apply my
favourite tools including Sass, gulp, ruby, and so on.

With the WordPress install running in =/var/www/sandbox_wp= under
=www-data=, I still needed a way to be able to edit files locally and
have them show up under the WordPress site.

The =wp-content= folder is used for a few things, but most important to
this task, I wanted to be able to have themes and plugins available for
local editing.

Logging into the VM, I created a folder =/vagrant/dev=, which would show
up on the local machine in the project root as just =dev/=.

#+BEGIN_SRC sh
    mkdir /vagrant/dev
#+END_SRC

Then I recursively copied the contents of
=/var/www/sandbox_wp/wp-content/themes= and
=/var/www/sandbox_wp/wp-content/plugins= to =/vagrant/dev/=, which
created two folders =/vagrant/dev/themes= and =/vagrant/dev/plugins=.

#+BEGIN_SRC sh
    cp -r /var/www/sandbox_wp/wp-content/themes /vagrant/dev
    cp -r /var/www/sandbox_wp/wp-content/plugins /vagrant/dev
#+END_SRC

*** Creating a little demo custom theme
    :PROPERTIES:
    :CUSTOM_ID: creating-a-little-demo-custom-theme
    :END:

To test things out, I created a custom theme under =dev/= on the local
machine, and filled with some bare-bones content:

#+BEGIN_SRC sh
    mkdir -p dev/themes/demo
#+END_SRC

The
[[https://github.com/tamouse/sandbox.wp.local/tree/master/dev/themes/demo][demo
content]] was pretty complicated to set up, and I'm not going into it
here. Easier would have been just making a child theme to try stuff out.

*** Telling WordPress about the Custom Theme
    :PROPERTIES:
    :CUSTOM_ID: telling-wordpress-about-the-custom-theme
    :END:

Back over on the VM, I needed to tell the WordPress installation about
this new custom theme:

#+BEGIN_SRC sh
    cd /var/www/sandbox_wp/wp-content/themes
    sudo ln -s /vagrant/dev/themes/demo .
#+END_SRC

Popping back over to the browser, and pulling up the Appearances ->
Themes menu, lo and behold, the custom theme now showed up.

** The development workflow
   :PROPERTIES:
   :CUSTOM_ID: the-development-workflow
   :END:

I now could edit files comfortably in my local editor of choice, saving
files, and view the results by refreshing the browser pointing at the
WordPress site running in the VM.

** Final Thoughts
   :PROPERTIES:
   :CUSTOM_ID: final-thoughts
   :END:

I created this set up initially during
[[https://2016.minneapolis.wordcamp.org/][WordCamp MSP 2016]] for the
fundamentals day so I could have a local hacking spot without trying to
roll up a remote server or build up a local server that I may not want
to keep around.

(This is why the demo custom theme is as complex as it is.)

One of the excellent things about using Vagrant and Ansible is the ease
of which you can spin something up again if you want to. However, for
future WordPress development work, I will probably be going with
[[https://local.getflywheel.com][Local]] because it is /such/ a slick
product, and that's what I'm recommending to my WordPress students.
