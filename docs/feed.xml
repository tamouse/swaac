<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://github.com/tamouse/swaac</id>
  <title>Tamouse&#39;s Software as a Craft blog</title>
  <updated>2018-12-12T22:56:53-06:00</updated>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/12/2018-12-12-tenants-of-toast-and-tech.org</id>
      <updated>2018-12-12T22:56:53-06:00</updated>
      <title>The Tenants of Toash and Tech</title>
      <content>* The Tenants of Toash and Tech

As some of you following know, I&#39;ve led this thing on Tuesday nights called &quot;Toast &amp; Tech&quot; for about 3 years [starting in the Autumn of 2015], nominally under the organization at .@GDImpls, the Minneapolis chapter of .@girldevelopit.

I have left that organization, but I want to leave behind something for those involved in T&amp;T, and for those looking to make a space for learning that it inclusive 2/

** The Tenants of Toast and Tech:

- make *everyone* welcome, enthusiastically
- make *all* questions welcome, enthusiastically
- everyone is learning, everyone is teaching
- there is no single path, there are as many paths as people attending, as many paths as needed
- you don&#39;t need a project or tech work to attend, just come
- you don&#39;t need any experience to attend, just come
- support everyone who shows up
- Make it safe to learn, safe to ask questions, safe to show up.

Possibly the *most* important tenant of all: #ToastAndTech can happen *anywhere*, run by *anyone*; all it takes is letting folks know about it, and showing up to hold the space.

#CauseAScene
#KeepLearning
#HappyToast

[[./kawaii-toast.png][happy toast]]
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/12/2018-12-01-polyfill-for-custom-event.org</id>
      <updated>2018-12-01T11:00:30-06:00</updated>
      <title>Polyfill for JavaScript&#39;s ~CustomEvent~ constructor</title>
      <content>* Polyfill for JavaScript&#39;s ~CustomEvent~ constructor

I had a project I needed to use a non-DOM event with, where a couple of React components were signaling a change in state, and they didn&#39;t share any context.

I could have used Redux, but that seemed like heavy lifting for only using an event, so I dug into using custom events.

The downside is that only since version 9 has Internet Explorer supported some form of ~CustomEvent~, and it is not the same. I was looking at other libraries until I happened on the polyfill provided by Mozilla at [[https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill][CustomEvent Polyfill on MDN]]. I copied that into a file and import it where I want to dispatch a custom event.

I attach the listeners in the various React components&#39; ~componentDidMount~ at the ~window~ DOM node as common ancestor for all components on the page, and remove them in ~componentWillUnmount~.
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/11/2018-11-29-thoughts-on-writing-good-tests.org</id>
      <updated>2018-11-29T14:54:22-06:00</updated>
      <title>Thoughts on learning to write good tests                          :testing:</title>
      <content>* Thoughts on learning to write good tests                          :testing:
  :PROPERTIES:
  :CAPTURE_DATE: [2018-11-29 Thu]
  :KEYWORDS: testing, learning, good tests
  :END:

- Time-stamp: &lt;2018-11-29 14:54:22 tamara&gt;
- current_date: [2018-11-29 Thu]
- keywords: testing, learning


Someone asked this question on the WWCodeTC #learning-to-code Slack channel the other day:

#+BEGIN_QUOTE
OP: I asked this in another group and I got a million answers but I&#39;ll ask here: anyone have a good way to learn how to write good tests? I&#39;ve listened to a test driven development course on lynda.com. I don&#39;t really have a specific question per se, just looking for a pointer to good testing practices beyond the basics.
#+END_QUOTE


My response:

#+BEGIN_QUOTE

everyone says testing is Super Important, but no one seems to definitively answer that question. the obvious answer is &quot;write a lot of bad tests&quot; but that is oh so dismal.

the stuff i learned from, ages and ages ago, is probably no longer in print, but look for these authors:

- jerry weinberg
- boris beizer
- larry constantine
- glen meyers
- bob grady

I met and worked these guys aeons ago, all really amazing authors

look up software quality institute,  I&#39;m not sure if it&#39;s still going

most all classes and tutorials i see are about how to write tests in a framework, which is good, but like most software education, never really gets at how to do design of software for a purpose and tests do need to fit a purpose

I&#39;ll just throw out a few questions you may want to try on as heuristics:

- what are the most critical actions or features users need to function impeccably
- what features are showing the most failures in use
- if a feature is unclear in how to use, how many ways can it be used or abused
- how can i break this?


another way to approach it is from the test driven side, and write tests that describe exactly what the feature does, does not do, responds to random input, responds to incorrect input, etc, so you completely spec the feature before any feature code is written.

#+END_QUOTE
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/11/2018-11-23-til-setting-window-location-in-jest-tests.org</id>
      <updated>2018-11-23T16:44:09-06:00</updated>
      <title>TIL: Setting `window.location` during Jest testing</title>
      <content>* TIL: Setting `window.location` during Jest testing
  :PROPERTIES:
  :CAPTURE_DATE: 2018-11-23
  :KEYWORDS: jest, window.location, testing
  :END:

- Time-stamp: &lt;2018-11-23 16:44:09 tamara&gt;
- capture_date: [2018-11-23 Fri]
- keywords: jest, window.location, testing


By default, the `window.location` properties are read-only. But for some tests, I need these to be specific, set values.

In [[https://github.com/facebook/jest/issues/890][Jest issue 890]] over on github, there is a long discussion about this, and ways people have solved this issue for themselves.

The first one I happened upon is one used by Facebook engineers:

I needed to modify `pathname` property only for my test:
#+BEGIN_SRC rjsx
  Object.defineProperties(window.location, &#39;pathname&#39;, {
      writeable: true,
      value: defaultPathname
  })
#+END_SRC



Here&#39;s a more universal one:

#+BEGIN_SRC rjsx
  const setURL = (url) =&gt; {
    const parser = document.createElement(&#39;a&#39;);
    parser.href = url;
    [&#39;href&#39;, &#39;protocol&#39;, &#39;host&#39;, &#39;hostname&#39;, &#39;origin&#39;, &#39;port&#39;, &#39;pathname&#39;, &#39;search&#39;, &#39;hash&#39;].forEach(prop =&gt; {
      Object.defineProperty(window.location, prop, {
        value: parser[prop],
        writable: true,
      });
    });
  };
#+END_SRC

The sneaky trick of creating a wee little parser out of a document anchor element is pretty dang cool, too.

Later in the issue page, there&#39;s some discussion about how this might break in future versions of `jsdom`, and another way to set the location property, by modifying the history on `window`:

#+name: package.json
#+begin_src js
  {
      &quot;testUrl&quot;: &quot;https://somehost.com/some/path/test.html&quot;
  }
#+end_src

And in your test setup:
#+BEGIN_SRC rjsx
  window.history.pushState({}, &#39;Test Title&#39;, &#39;/another/path/test.html?query=true&#39;);
#+END_SRC

This is from the [[https://www.ryandoll.com/post/2018/3/29/jest-and-url-mocking][Jest and URL testing]] by Ryan Doll.
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/11/2018-11-20-til-input-file-has-accepts-attribute.org</id>
      <updated>2018-11-20T00:30:53-06:00</updated>
      <title>TIL: The ~input[type=file]~ element has an ~accepts~ attribute</title>
      <content>* TIL: The ~input[type=file]~ element has an ~accepts~ attribute

- Time-stamp: &lt;2018-11-20 00:30:53 tamara&gt;
- capture date: [2018-11-20 Tue]
- keywords: html, input, file, pass list

The ~input[type=file]~ element has an attribute, ~accepts~ that provides a pass filter for the types of files that are accepted in the input file field. See [[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept][the MDN documentation for input accept]] for details.

This means, if I have a set of allowed extensions, I can put them in the ~accepts~ field to limit what the user can select:

#+BEGIN_SRC html
  &lt;!-- to accept all image types --&gt;
  &lt;input type=&quot;file&quot; name=&quot;image_file&quot; accept=&quot;image/*&quot;&gt;

  &lt;!-- to accept various file extensions --&gt;
  &lt;input type=&quot;file&quot; name=&quot;data&quot; accept=&quot;.jpg,.jpeg,.gif,.png,.bmp,.pdf,.txt,.md,.markdown&quot;&gt;
#+END_SRC

With a little more work, if there is a pass list of extensions on the server, I could pass it down to the client via the ~gon~ object where a React client could pick it up.


#+name: config/constants.rb
#+begin_src ruby
  module App
    module CONSTANTS
      UPLOAD_PASS_LIST = %w[
        jpg
        jpeg
        png
        gif
        bmp
        pdf
        text
        txt
        markdown
        md
        csv
        xls
        xlsx
        doc
        docx
      ].freeze
    end
  end
#+end_src

#+name: app/controllers/application_controller
#+begin_src ruby
  before_action :export_upload_pass_list

  # ...

  def export_upload_pass_list
    gon.push(upload_pass_list: App::CONSTANTS::UPLOAD_PASS_LIST)
  end
#+end_src

#+name: upload_file_form.js
#+begin_src jsx

  accepts_list = () =&gt; {
      return gon.upload_pass_list.map(ext =&gt; `.${ext}`).join(&quot;,&quot;)
  }

  render() {
      return (
          &lt;input
            type=&quot;file&quot;
            name=&quot;data&quot;
            accepts={this.accepts_list()}
            onChange={this.fileChange}
          /&gt;
      )
  }

#+end_src
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/11/2018-11-14-video-of-storybook-for-react-talk-from-october-2018.org</id>
      <updated>2018-11-14T21:08:10-06:00</updated>
      <title>Video of Storybook for React talk from October 2018</title>
      <content>* Video of Storybook for React talk from October 2018

  - Time-stamp: &lt;2018-11-06 20:08:58 tamara.temple&gt;
  - capture date: [2018-11-06 Tue 19:59]
  - keywords: react, storybook, presentation

** Intro

   In October 2018, I gave a talk / tutorial on [[https://storybook.js.org/basics/introduction/][Storybook]], an environment for developing visual components, and how I&#39;m using it in developing React components at work, for [[https://twitter.com/ReactMpls][React Minneapolis meetup]].

** Video

   The talk was recorded, and video is up at [[https://youtu.be/9B-IB2U3qSI][yahoo]].

#+BEGIN_EXPORT html
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/9B-IB2U3qSI&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
#+END_EXPORT
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/11/2018-11-14-link-css-frameworks-vs-grid.org</id>
      <updated>2018-11-14T21:04:07-06:00</updated>
      <title>LINK: CSS Frameworks vs. CSS Grid</title>
      <content>* LINK: CSS Frameworks vs. CSS Grid

- Time-stamp: &lt;2018-11-14 21:04:07 tamara&gt;
- capture date: [2018-11-14 Wed 20:58]
- keywords: CSS, Grid, Frameworkds, Bootstrap, Rachel Andrew, good advice, Smashing Magazine

- Link: [[https://www.smashingmagazine.com/2018/11/css-frameworks-css-grid/]]

** Quick Summary

#+BEGIN_QUOTE
Have you ever considered whether CSS Grid can actually replace the need for CSS frameworks or third-party component libraries? In doing so, Rachel Andrew discovered a range of reasons people use a third-party framework and the positive and negative things about doing so.
#+END_QUOTE

** Thoughts

I love reading [[https://www.smashingmagazine.com/author/rachel-andrew][Rachel Andrew]]&#39;s posts, everywhere, not just on SmashingMagazine. This one is no different. Rachel is no hardline &quot;you have to use my stuff&quot; writer, she&#39;s thoughtfully laid out good reasons for using a CSS framework like Bootstrap, and even given other people&#39;s answers as to why it&#39;s a good choice. She&#39;s also given reasons for *not* using a framework, and why that&#39;s a good choice.

Her conclusion, for those coming down on the side of &quot;no framework&quot; are some pretty good steps, and even might help you decide if it&#39;s worth going your own way.
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/11/2018-11-06-posting-a-file-with-XMLHttpRequest.org</id>
      <updated>2018-11-06T14:26:38-06:00</updated>
      <title>RESEARCH: Posting a file with XMLHttpRequest</title>
      <content>* RESEARCH: Posting a file with XMLHttpRequest

- Time-stamp: &lt;2018-11-06 14:26:38 tamara&gt;
- published date: [2018-11-06 Tue 13:46]
- keywords: XMLHttpRequest, file upload, JavaScript, research, React


See: [[https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Using_nothing_but_XMLHttpRequest][Using nothing but XMLHttpRequest]] &lt;-- maybe not

See: [[https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Using_FormData_objects][Using FormData objects]] &lt;-- necessary for files, I think

In contrast to [[./posting-a-file-with-fetch-api.org][Posting with Fetch API]], this is a bit lower on the food chain in terms of JS stuff, *but* it lets you get access to ~progress~ events, for doing such things as displaying a progress bar. Yay.

** Using FormData

MDN makes a special note:

#+BEGIN_QUOTE
Note: As we said, FormData objects are not stringifiable objects. If you want to stringify a submitted data, use the previous pure-AJAX example. Note also that, although in this example there are some file &lt;input&gt; fields, when you submit a form through the FormData API you do not need to use the FileReader API also: files are automatically loaded and uploaded.
#+END_QUOTE

** Using Event Handlers

From the top of the page, just using / setting event handlers:

#+BEGIN_SRC rjsx
  function reqListener () {
    console.log(this.responseText);
  }

  var oReq = new XMLHttpRequest();

  // this sets the &#39;load&#39; event handler, which fires when the file is fully loaded.
  // I think this works for POST/PUT as well...
  oReq.addEventListener(&quot;load&quot;, reqListener);

  oReq.open(&quot;GET&quot;, &quot;http://www.example.org/example.txt&quot;);
  oReq.send();
#+END_SRC

There&#39;s a note [[https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Monitoring_progress][somewhere on the page]] saying something about ~progress~ event handlers needing to be set before the ~.open~ call.

This would load up all the event handlers for XMLHttpRequest:

#+BEGIN_SRC rjsx
  let oReq = new XMLHttpRequest();

  oReq.addEventListener(&quot;progress&quot;, updateProgress);
  oReq.addEventListener(&quot;load&quot;, transferComplete);
  oReq.addEventListener(&quot;error&quot;, transferFailed);
  oReq.addEventListener(&quot;abort&quot;, transferCanceled);

  oReq.open();
#+END_SRC

** Progress Indication

The ~progress~ event handler takes in the progress event, which is defined at [[https://xhr.spec.whatwg.org/#interface-progressevent][WhatWG Progress Event specification]]. It has 3 attributes:

- ~lengthComputable~ [boolean] whether the length of the object is known
- ~loaded~ [number] how much has loaded so far
- ~total~ [number] how much there is to load

So progress can be calculated by:

#+BEGIN_SRC rjsx
  handleProgress = event =&gt; {
      let progress = 0
      if (event.total !== 0) {
          progress = event.loaded / event.total
      }
      const percentCompleted = progress * 100
      this,setState({ progress, percentCompleted })
  }

  handleLoaded = event =&gt; {
      this.setState({ progress: 1, percentCompleted: 100, loaded: true })
  }

  // ...

  request = () =&gt; {

      const req = new XMLHttpRequest()

      req.addEventListener(&#39;progress&#39;, this.handleProgress)
      req.addEventListener(&#39;load&#39;, this.handleLoaded)

      // ... etc
  }
#+END_SRC
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2018/11/2018-11-06-posting-a-file-with-fetch-api.org</id>
      <updated>2018-11-06T13:37:57-06:00</updated>
      <title>Posting a file using the fetch API</title>
      <content>* Posting a file using the fetch API
- Time-stamp: &lt;2018-11-06 13:37:57 tamara&gt;
- published date: [2018-11-06 Tue 13:17]
- keywords: javascript, fetch, file upload

I&#39;m investigating this for work

See [[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Uploading_a_file][MDN: Uploading a file (fetch)]]

#+BEGIN_QUOTE
Files can be uploaded using an HTML &lt;input type=&quot;file&quot; /&gt; input element, FormData() and fetch().
#+END_QUOTE

#+BEGIN_SRC rjsx
  let formData = new FormData();

  const fileField = document.querySelector(&quot;input[type=&#39;file&#39;]&quot;);

  formData.append(&#39;username&#39;, &#39;abc123&#39;);

  // file fields provide a collection of files, apparently.
  formData.append(&#39;avatar&#39;, fileField.files[0]);

  fetch(&#39;https://example.com/profile/avatar&#39;, {
      method: &#39;PUT&#39;,
      headers: {
          &#39;Content-type&#39;: &#39;application/x-www-form-urlencoded&#39;
      },
      body: formData,
  })
      .then(response =&gt; response.json())
      .catch(error =&gt; console.error(&#39;Error:&#39;, error))
      .then(response =&gt; console.log(&#39;Success:&#39;, JSON.stringify(response)));
#+END_SRC
In a React context, the information would be obtained using a React `ref` instead of the POJS `querySelector`, but it ends up close to the same afterwards:

#+BEGIN_SRC rjsx
  fileFieldRef = React.createRef()

  handleSubmit = () =&gt; {
      let formData = new FormData()
      const fileField = this.fileFieldRef.current

      formData.append(&#39;username&#39;, &#39;abc123&#39;)
      formData.append(&#39;avatar&#39;, fileField.files[0])

      fetch(&#39;https://example.com/profile/avatar&#39;, {
          method: &#39;PUT&#39;,
          headers: {
              &#39;Content-type&#39;: &#39;application/x-www-form-urlencoded&#39;
          },
          body: formData,
      })
          .then(response =&gt; response.json())
          .catch(error =&gt; console.error(&#39;Error:&#39;, error))
          .then(response =&gt; console.log(&#39;Success:&#39;, JSON.stringify(response)));
  }

  // ...

  render() {
      return (
          &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;input type=&quot;file&quot; ref={this.fileFieldRef}/&gt;
          &lt;/form&gt;
      )
  }
#+END_SRC
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
    <entry>
      <id>https://github.com/tamouse/swaac/blob/master/posts/2017/07/setting-up-your-mac-for-working-on-the-command-line.org</id>
      <updated>2018-11-06T09:32:33-06:00</updated>
      <title>Setting up your Mac for working on the command line.</title>
      <content>* Setting up your Mac for working on the command line.
- Time-stamp: &lt;2018-11-06 09:32:33 tamara&gt;
- published date: 2017-07
- keywords: command line, cli, termoial, mac

Before beginning, I strongly urge you to get Michael Hartl&#39;s [[https://www.learnenough.com/command-line-tutorial][Learn Enough Command Line to Be Dangerous]] which is seriously the best introduction to this whole thing.

See also: [Conventions Used in This Section]({{ &quot;/pages/learning/beginner/conventions-used-in-this-section&quot;}}).

** Intro

I&#39;d love to provide the TL;DR for this, but I can&#39;t. I don&#39;t know what&#39;s on your system already, what level you&#39;re at, or even a kind voice to listen to your questions and respond.

Using the caommand line effectively means having it configured to your needs. So this page is going to introduce how to configure your command line.

There are two, sometimes three, files involved in this:

- =.bash_profile=
- =.profile=
- =.bashrc=

The rest of this will tell you how to set them up.

** You&#39;ll need to know

- [[file:%7B%7B%20site.baseurl%20%7D%7D/pages/learning/beginner/how-do-i-get-to-the-command-line-on-a-mac/][How to open Terminal on a Mac]]
- Various shell commands:

  - =cd=
  - =chmod=
  - =cp=
  - =echo=
  - =ls=

** Gathering Current Information

1. [[file:%7B%7B%20site.baseurl%20%7D%7D/pages/learning/beginner/how-do-i-get-to-the-command-line-on-a-mac/][Open up the Terminal]]

2. Run the command:

#+BEGIN_EXAMPLE
    ls -1 .profile .bash_profile .bashrc
#+END_EXAMPLE

The &quot;-1&quot; (&quot;minus-one&quot;) option produces a listing of file names in a single column. It&#39;s not necessary, but it&#39;s a little easier to read for short listings.

The =ls= command has /lots/ of options which can be learned about using the =man ls= command and reading the manual page.

You could see something like the following:

#+BEGIN_EXAMPLE
       ls: .bash_profile: No such file or directory
       ls: .bashrc: No such file or directory
       ls: .profile: No such file or directory
#+END_EXAMPLE

in which case you don&#39;t have any of those files, which is okay.

You might see something like this:

#+BEGIN_EXAMPLE
       ls: .bash_profile: No such file or directory
       ls: .profile: No such file or directory
       .bashrc
#+END_EXAMPLE

in which case you have the =.bashrc= file, but you don&#39;t have the others, which is also okay.

In fact, /any/ combination is okay, there&#39;ll be a section below on each case.

Here are the combinations:

1. You don&#39;t have any of them (default OSX setup)
2. You have =.profile= but not the other two
3. You have =.bash_profile= but not the other two
4. You have =.bashrc= but not the other two
5. You have =.bash_profile= and =.bashrc=, but not =.profile=
6. You have =.profile= and =.bashrc=, but not =.bash_profile=
7. You have all three

** If you don&#39;t have any of the three files

In this section, we&#39;ll talk about when none of those files exist yet. This is easiest to deal with starting off.

*** What are the =.bash_profile= and =.profile= file about?

On Unix- and Linux-based systems, the command line is also referred to as &quot;The Shell&quot;. By default, Mac&#39;s use the program &quot;bash&quot; as the command line shell.

When you start up Terminal, it launches a &quot;login shell&quot; by starting the program =/bin/bash=. This program then looks for two files in your user&#39;s [home directory][homedir]: =.bash_profile= and =.profile=.

It&#39;s important to note that if =bash= finds =.bash_profile=, it will run that file, otherwise it will run =.profile=. There may come a time when you install a software development command-line tool that creates a =.bash_profile=, and you can find all the things you put in =.profile= are not being set up. Likewise, you might install a software command line tool that only expects things to be initialized in =.profile= and then that tool&#39;s setting won&#39;t happen correctly. It&#39;s confusing, to be sure.

There&#39;s always more than one way to deal with this, of course. Perhaps the best way is to start with the =.bash_profile= and make all your initialisation happen there.

I prefer to do the following though:

1. Create a =.bash_profile= in your home directory with the following contents:

#+BEGIN_EXAMPLE
       #!/bin/bash
       [ -f $HOME/.profile ] &amp;&amp; source $HOME/.profile
#+END_EXAMPLE

What this does is execute the =.profile= file if it exists. In this way you can have initialisation code put in either file and it will be run. The /major/ caveat on this is to make sure if there&#39;s initialisation code in both =.bash_profile= and =.profile= it does not cause any problems if it gets run twice. Usually this is okay, but it can be a source of errors.

2. Create the =.profile= file and place the initialisation codes you want to manage there.

*** The =.profile= file

As noted, this file contains initialisation codes. Here&#39;s where you can set environment variables that are used throughout your command line sessions.

One such environment variable is =PATH= -- this is the variable used to find command line programs on your computer. Sometimes you&#39;ll need to extend this variable when you install a new piece of software.

Jump into your command line now and type:

#+BEGIN_EXAMPLE
    $ echo $PATH
#+END_EXAMPLE

Incidently, that /first/ &quot;$&quot; on the line above is *not* part of the command; it is there to indicate the command line prompt (which could be much more complicated). It&#39;s used here to tell you something you should be typing. What you&#39;ll actually type is what follows the space after the &quot;$&quot;, i.e. just &quot;echo $PATH&quot;.

On the stock Mac install, you&#39;ll probably see something like:

#+BEGIN_EXAMPLE
    /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
#+END_EXAMPLE

(It might be slightly different, or it might have been changed previously.)

Let&#39;s take the case where you just recently install the &quot;Sass&quot; program which pre-processed CSS files in a special format. After you&#39;ve run the =gem install sass --user-install= command, you may have seen a warning like the following:

#+BEGIN_EXAMPLE
    WARNING:  You don&#39;t have /Users/noob/.gem/ruby/2.0.0/bin in your PATH, gem executables will not run.
#+END_EXAMPLE

While not an error, not addressing this warning is going to be very painful for you.

So let&#39;s add that indicated directory to our PATH environment variable. We do this in the =.profile= file like so:

#+BEGIN_EXAMPLE
    export PATH=$PATH:$HOME/.gem/ruby/2.0.0/bin
#+END_EXAMPLE

Save and close your =.profile= file, switch back to your command line, and type the following:

#+BEGIN_EXAMPLE
    $ source $HOME/.profile
    $ echo $PATH
#+END_EXAMPLE

Now you should see the following:

#+BEGIN_EXAMPLE
    usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/noob/.gem/ruby/2.0.0/bin
#+END_EXAMPLE

** If you have =.bash_profile=, but none of the others

If you already have one, the easiest is to add the following line at the bottom of the file:

#+BEGIN_EXAMPLE
    [ -f $HOME/.profile ] &amp;&amp; source $HOME/.profile
#+END_EXAMPLE

then save and close the file.

Then open a new file named =.profile= and enter the following in it:

#+BEGIN_EXAMPLE
    \#!/bin/bash
#+END_EXAMPLE

Then you can add whatever other initialisation codes you want in =.profile=. Follow the example in the previous section to append something to your =PATH= environment variable.

** If you have =.profile=, but none of the others

Create a =.bash_profile= in your home directory with the following contents:

#+BEGIN_EXAMPLE
    \#!/bin/bash
    [ -f $HOME/.profile ] &amp;&amp; source $HOME/.profile
#+END_EXAMPLE

That&#39;s all, really.

** If you do NOT have a =.bashrc= file

This is the default starting point for a new user.

*** What is the =.bashrc= file all about?

The =.bashrc= file in your home directory will be executed whenever an /interactive/ shell gets invoked. Calling =bash= from the command line from a is considered an /interactive/ shell. It is /not/ run, however, when a /login/ shell is started, which is what happens when you start up a new Terminal window.

Confusing? Yes. Try the following to see what is happening.

Edit your =.profile= and add the following line to the end:

#+BEGIN_EXAMPLE
    echo &quot;.profile ran&quot;
#+END_EXAMPLE

Edit =.bashrc= (creating it if necessary) and put the following at the end:

#+BEGIN_EXAMPLE
    echo &quot;.bashrc ran&quot;
#+END_EXAMPLE

Now open a /new/ Terminal window (Command-N) and see what is printed. You should /just/ see &quot;.profile ran&quot; before the prompt:

#+BEGIN_EXAMPLE
    .profile ran
    $
#+END_EXAMPLE

Your command prompt will be different of course.

Now run an interactive bash:

#+BEGIN_EXAMPLE
    $ bash
#+END_EXAMPLE

You should now see something like:

#+BEGIN_EXAMPLE
    .bashrc ran
    bash-3.2$
#+END_EXAMPLE

You can see that the =.bashrc= file is not run on starting up a new window. (You might also see your command prompt change! We&#39;ll fix that in a second.)

What we actually /want/ usually, is to have the =.bashrc= file run for a login shell as well.

To do that, we need to fix up the =.profile= file with the following line at the end of the file:

#+BEGIN_EXAMPLE
    [ -x $HOME/.bashrc ] &amp;&amp; source $HOME/.bashrc
#+END_EXAMPLE

This will cause the =.bashrc= file to be executed at the end of the =.profile= file&#39;s executing but only /if/ the =.bashrc= file is *executable*.

This gives a little extra control, if we don&#39;t want =.bashrc= to run at login, we can unset it&#39;s execution bit. But for now, let&#39;s set it:

#+BEGIN_EXAMPLE
    $ chmod +x $HOME/.bashrc
    $ ls -l .bashrc
#+END_EXAMPLE

And you should see something like:

#+BEGIN_EXAMPLE
    \-rwxr-xr-x  1 noob  staff  32 Aug  7 01:01 .bashrc
#+END_EXAMPLE

Which shows it&#39;s become executable for everyone on the system.

Close the Terminal window and open a new one. Now you should see the following before the first command line prompt:

#+BEGIN_EXAMPLE
    .bashrc ran
    .profile ran
#+END_EXAMPLE

You can remove those two &quot;echo&quot; commands from =.profile= and =.bashrc= if you wish, or leave them in as tracers while you&#39;re working with them.

*** Creating the =.bashrc= file

This file initialized /each/ interactive shell, including setting some environment variables used by =bash=, aliases, and other settings.

There is a global =/etc/bashrc= file that is a good starting point for your own.

Run the following command:

#+BEGIN_EXAMPLE
    $ cp /etc/bashrc $HOME/.bashrc
#+END_EXAMPLE

This will *overwrite* the =.bashrc= file you just made, but that&#39;s okay since there really wasn&#39;t anything in it.

Give the new file execute permission:

#+BEGIN_EXAMPLE
    $ chmod +x $HOME/.bashrc
#+END_EXAMPLE

Close the Terminal window and open a new one.

** If you have =.bashrc= but neither =.bash_profile= or =.profile=

In this case, you want to add running the =.bashrc= file for /login/ shells so those settings are available.

Add the following line to the end of your =.profile=:

#+BEGIN_EXAMPLE
    [ -x $HOME/.bashrc ] &amp;&amp; source $HOME/.bashrc
#+END_EXAMPLE

as in the previous section. You may need to set the execute bit on =.bashrc= as well:

#+BEGIN_EXAMPLE
    $ chmod +x .bashrc
#+END_EXAMPLE

** If you have =.bashrc=, and one or both of =.bash_profile= and =.profile=

If you only have one of =.bash_profile= or =.profile= see the appropriate section above.

Make sure one of those two files is calling =.bashrc= as in the previous section. If neither do, put the line into =.profile=.
</content>
      <author>
        <name>Tamara Temple</name>
        <email>tamara@tamouse.org</email>
      </author>
    </entry>
</feed>
